<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Scheduler</title>
    <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.css" rel="stylesheet" />
    <style>
      html, body { height: 100%; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; overflow: hidden; }
      #app { display: grid; grid-template-columns: 300px 1fr; height: 100vh; }
      aside { border-right: 1px solid #e5e7eb; padding: 12px; overflow: auto; }
      main { padding: 12px; display: flex; flex-direction: column; overflow: hidden; }
      .tag-values { display: flex; flex-direction: column; gap: 6px; max-height: 40vh; overflow: auto; }
      .tag-line { display:flex; align-items:center; gap:6px; }
      .color-dot { display:inline-block; width: 10px; height: 10px; border-radius: 50%; border:1px solid #d1d5db; }
      .filters { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; }
      .section { margin-top: 16px; }
      .row { display: flex; align-items: center; gap: 6px; }
      .muted { color: #6b7280; font-size: 12px; }
      button { cursor: pointer; }
      input[type="text"], input[type="datetime-local"] { padding: 6px; }
      /* Modal */
      .hidden { display: none; }
      .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); display: flex; align-items: center; justify-content: center; z-index: 50; }
      .modal-backdrop.hidden { display: none !important; }
      .modal { background: #fff; border-radius: 8px; padding: 16px; width: 520px; max-width: calc(100% - 24px); box-shadow: 0 10px 30px rgba(0,0,0,.2); }
      .modal h3 { margin: 0 0 12px 0; }
      .modal .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .modal .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
      .tag-groups { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; max-height: 220px; overflow: auto; border: 1px solid #e5e7eb; padding: 8px; border-radius: 6px; }
      .tag-group { border: 1px dashed #e5e7eb; padding: 6px; border-radius: 6px; }
      .tag-group strong { font-size: 12px; color: #374151; }
      .tag-list, .value-list { display: flex; flex-direction: column; gap: 4px; margin: 6px 0; }
      .tag-header { display: flex; align-items: center; justify-content: space-between; gap: 6px; }
      /* Календарь занимает всю доступную высоту, скролл только внутри него */
      #calendar { flex: 1; min-height: 0; }
      /* Подсветка выходных (суббота и воскресенье) */
      .fc .fc-col-header-cell.fc-day-sat,
      .fc .fc-col-header-cell.fc-day-sun { background: #f8fafc; }
      .fc .fc-daygrid-day.fc-day-sat,
      .fc .fc-daygrid-day.fc-day-sun { background: #f8fafc; }
      .fc .fc-timegrid-col.fc-day-sat,
      .fc .fc-timegrid-col.fc-day-sun { background: #f8fafc; }
      /* Мобильная панель и drawer */
      .mobile-bar { display: none; }
      .mobile-calbar { display: none; align-items: center; gap: 8px; margin-bottom: 8px; }
      .mobile-calbar .nav { display:flex; gap:6px; align-items:center; }
      .mobile-calbar .title { flex:1; text-align:center; font-weight:600; }
      .segmented { display:flex; border:1px solid #e5e7eb; border-radius:6px; overflow:hidden; }
      .segmented button { background:#fff; border:0; padding:6px 10px; cursor:pointer; }
      .segmented button.active { background:#111827; color:#fff; }
      .drawer { position: fixed; inset: 0; background: rgba(0,0,0,.35); display: none; z-index: 60; }
      .drawer.open { display: block; }
      .drawer-panel { width: 86vw; max-width: 360px; height: 100%; background: #fff; padding: 12px; overflow: auto; border-right: 1px solid #e5e7eb; }
      .drawer-header { display:flex; align-items:center; justify-content: space-between; margin-bottom: 8px; }
      .drawer-close { background: transparent; border: none; font-size: 18px; cursor: pointer; }
      /* Печатная легенда по цветам скрыта по умолчанию */
      .print-legend { display: none; font-size: 12px; color: #374151; }
      .print-legend .legend-title { margin-bottom: 4px; }
      .print-legend .legend-items { display: flex; flex-wrap: wrap; gap: 10px; }
      .print-legend .legend-item { display: inline-flex; align-items: center; gap: 4px; }
      .print-filters { display: none; font-size: 12px; color: #374151; }
      @media (max-width: 768px){
        #app { grid-template-columns: 1fr; }
        aside { display: none; }
        .mobile-bar { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .mobile-calbar { display: flex; }
        /* Спрятать стандартный header календаря на мобильных */
        .fc .fc-header-toolbar { display: none; }
      }
      @media print{
        #app { grid-template-columns: 1fr; }
        aside { display: none !important; }
        .mobile-bar, .mobile-calbar { display: none !important; }
        .fc .fc-header-toolbar { display: none; }
        /* Занять доступную область печати: убрать фиксированные высоты и скроллы */
        html, body { height: auto; overflow: visible; }
        #app { height: auto; }
        main { overflow: visible; }
        #calendar { height: auto !important; min-height: 0; }
        .fc, .fc .fc-scroller { height: auto !important; max-height: none !important; overflow: visible !important; }
        /* Убрать подсветку текущего дня */
        .fc .fc-col-header-cell.fc-day-today,
        .fc .fc-daygrid-day.fc-day-today,
        .fc .fc-timegrid-col.fc-day-today,
        .fc .fc-day-today { background: transparent !important; }
        /* Показать легенду и выбранные фильтры при печати (в одну строку) */
        .print-legend { display: inline-block; margin-bottom: 8px; }
        .print-filters { display: inline-block; margin-left: 12px; }
        .print-legend .legend-title { display: inline; margin: 0; margin-right: 8px; }
        .print-legend .legend-items { display: inline-flex; gap: 10px; flex-wrap: nowrap; white-space: nowrap; }
        .print-legend .legend-item { white-space: nowrap; }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <aside>
        <div class="row" style="justify-content: space-between; align-items: baseline;">
          <h3 style="margin:0;">Фильтры</h3>
          <a href="/tags.html" class="muted">редактировать</a>
        </div>
        <div id="filters"></div>
        <button id="createBtn">+ Событие</button>
      </aside>
      <main>
        <div class="mobile-bar">
          <button id="openFiltersBtn">Фильтры</button>
          <button id="createBtnMobile">+ Событие</button>
        </div>
        <div class="mobile-calbar">
          <div class="nav">
            <button id="mbPrev">‹</button>
            <button id="mbToday">today</button>
            <button id="mbNext">›</button>
          </div>
          <div id="mbTitle" class="title"></div>
          <div class="segmented">
            <button id="mbMonth">month</button>
            <button id="mbDay" class="active">day</button>
          </div>
        </div>
        <div>
          <span id="printLegend" class="print-legend"></span>
          <span id="printFiltersSelected" class="print-filters"></span>
        </div>
        <div id="calendar"></div>
      </main>
    </div>

    <!-- Мобильный drawer с фильтрами -->
    <div id="filtersDrawer" class="drawer">
      <div class="drawer-panel">
        <div class="drawer-header">
          <strong>Фильтры</strong>
          <button id="drawerClose" class="drawer-close" aria-label="Закрыть">×</button>
        </div>
        <div id="filtersDrawerContent"></div>
        <button id="createBtnDrawer">+ Событие</button>
      </div>
    </div>

    <!-- Модальное окно события -->
    <div id="eventModalWrap" class="modal-backdrop hidden">
      <div class="modal">
        <h3 id="eventModalTitle">Событие</h3>
        <div class="grid">
          <div class="row" style="justify-content:space-between; align-items:center; gap:8px;">
            <input id="evTitle" type="text" placeholder="Название" style="width:100%"/>
            <label class="muted" style="white-space:nowrap;">
              <input id="evCanceled" type="checkbox"/> Отмена
            </label>
          </div>
          <div class="row" style="justify-content:flex-end; gap:6px;">
            <label class="muted" for="evCopySelect">Скопировать...</label>
            <select id="evCopySelect">
              <option value="">—</option>
              <option value="1d">На завтра</option>
              <option value="7d">Через неделю</option>
              <option value="14d">На 2 недели</option>
              <option value="21d">На 3 недели</option>
              <option value="28d">На 4 недели</option>
            </select>
          </div>
          <div>
            <label class="muted">Начало</label>
            <input id="evStart" type="datetime-local" style="width:100%"/>
          </div>
          <div>
            <label class="muted">Окончание</label>
            <input id="evEnd" type="datetime-local" style="width:100%"/>
          </div>
          <div>
            <label class="muted">Instagram</label>
            <input id="evContact" type="text" placeholder="Instagram" style="width:100%"/>
          </div>
          <div style="grid-column: 1 / -1;">
            <label class="muted">Значения тегов</label>
            <div id="evTagGroups" class="tag-groups"></div>
          </div>
        </div>
        <div class="actions">
          <button id="evDeleteBtn" style="margin-right:auto; color:#b91c1c;">Удалить</button>
          <button id="evCancelBtn">Отмена</button>
          <button id="evSaveBtn">Сохранить</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>
    <script>
      const API = '/api';

      async function fetchJSON(url, opts) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      // Утилита: форматировать ISO в локальное время без секунд: YYYY-MM-DD HH:MM
      function formatLocalNoSeconds(iso){
        const d = new Date(iso);
        const pad = (n)=> String(n).padStart(2,'0');
        const yyyy = d.getFullYear();
        const mm = pad(d.getMonth()+1);
        const dd = pad(d.getDate());
        const hh = pad(d.getHours());
        const mi = pad(d.getMinutes());
        return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
      }
      // Заменить все ISO-строки в сообщении об ошибке на локальный формат без секунд
      function beautifyErrorMessage(msg){
        const isoRe = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})/g;
        return String(msg).replace(isoRe, (m)=>{
          try { return formatLocalNoSeconds(m); } catch(_) { return m; }
        });
      }

      // Глобальные состояния
      let TAG_GROUPS = [];
      let SELECTED = new Set();
      let SHOW_CANCELED = true;

      async function loadTagsWithValues() {
        const tags = await fetchJSON(`${API}/tags`);
        const result = [];
        for (const t of tags) {
          const values = await fetchJSON(`${API}/tags/${t.id}/values`);
          result.push({ tag: t, values });
        }
        TAG_GROUPS = result;
        return result;
      }

      function renderFilters(cont, groups, state) {
        cont.innerHTML = '';
        // Выпадающий список для выбора основного тега для подсветки
        const selectWrap = document.createElement('div'); selectWrap.className = 'tag-values';
        const selectTitle = document.createElement('div'); selectTitle.className='muted'; selectTitle.textContent = 'Основной тег для подсветки:';
        selectWrap.appendChild(selectTitle);
        const select = document.createElement('select');
        for (const g of groups) {
          const opt = document.createElement('option');
          opt.value = String(g.tag.id);
          opt.textContent = g.tag.name;
          select.appendChild(opt);
        }
        if (!window.highlightTagId && groups.length) {
          window.highlightTagId = groups[0].tag.id;
        }
        if (window.highlightTagId) {
          select.value = String(window.highlightTagId);
        }
        select.addEventListener('change', () => {
          window.highlightTagId = Number(select.value);
          if (window.calendar) window.calendar.refetchEvents();
          if (window.syncPrintLegend) window.syncPrintLegend();
        });
        selectWrap.appendChild(select);
        cont.appendChild(selectWrap);
        // Флажок отображения отменённых
        const canceledWrap = document.createElement('div'); canceledWrap.className = 'tag-values';
        const canceledLabel = document.createElement('label'); canceledLabel.className='tag-line';
        const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = SHOW_CANCELED; chk.id='showCanceled';
        canceledLabel.appendChild(chk);
        canceledLabel.appendChild(document.createTextNode(' Показывать отмененные'));
        chk.addEventListener('change', ()=>{ SHOW_CANCELED = chk.checked; if(window.calendar) window.calendar.refetchEvents(); if(window.syncPrintLegend) window.syncPrintLegend(); });
        canceledWrap.appendChild(canceledLabel);
        cont.appendChild(canceledWrap);
        // Чекбоксы для фильтрации по значениям
        for (const g of groups) {
          const h = document.createElement('div');
          h.innerHTML = `<strong>${g.tag.name}</strong>`;
          cont.appendChild(h);
          const box = document.createElement('div');
          box.className = 'tag-values';
          for (const v of g.values) {
            const id = `tv-${v.id}`;
            const checked = state.has(v.id) ? 'checked' : '';
            const item = document.createElement('label');
            item.innerHTML = `<input type="checkbox" id="${id}" ${checked}/> <span class="color-dot" style="background:${v.color || '#9ca3af'}"></span> ${v.value}`;
            item.querySelector('input').addEventListener('change', (e)=>{
              if (e.target.checked) state.add(v.id); else state.delete(v.id);
              window.calendar.refetchEvents();
              if(window.syncFiltersUI) window.syncFiltersUI();
              if(window.syncPrintLegend) window.syncPrintLegend();
            });
            box.appendChild(item);
          }
          cont.appendChild(box);
        }
      }

      // Управление тегами вынесено на /tags.html. На главной оставлены только фильтры.

      function renderPrintLegend(container, group){
        container.innerHTML = '';
        if(!group) return;
        const title = document.createElement('div');
        title.className = 'legend-title';
        title.textContent = `Легенда: ${group.tag.name}`;
        container.appendChild(title);
        const items = document.createElement('div');
        items.className = 'legend-items';
        for(const v of group.values){
          const item = document.createElement('div'); item.className = 'legend-item';
          const dot = document.createElement('span'); dot.className = 'color-dot'; dot.style.background = v.color || '#9ca3af';
          const label = document.createElement('span'); label.textContent = v.value;
          item.appendChild(dot); item.appendChild(label);
          items.appendChild(item);
        }
        container.appendChild(items);
      }
      function renderPrintFiltersSelected(container, groups, selected){
        container.textContent = '';
        const segs = [];
        for(const g of groups){
          const vals = g.values.filter(v => selected.has(v.id)).map(v => v.value);
          if(vals.length){ segs.push(`${g.tag.name}: ${vals.join(', ')}`); }
        }
        if (SHOW_CANCELED) {
          segs.push('включая отмененные');
        }
        if(segs.length){ container.textContent = `Фильтры: ${segs.join(' | ')}`; }
      }

      // МОДАЛ СОБЫТИЯ
      function isoToLocalInputValue(iso){
        const d = new Date(iso);
        const pad = (n)=> String(n).padStart(2,'0');
        const yyyy = d.getFullYear();
        const mm = pad(d.getMonth()+1);
        const dd = pad(d.getDate());
        const hh = pad(d.getHours());
        const mi = pad(d.getMinutes());
        return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
      }
      function localInputToIso(val){
        const d = new Date(val);
        return d.toISOString();
      }

      function renderTagCheckboxes(container, selectedIds){
        container.innerHTML = '';
        for(const g of TAG_GROUPS){
          const box = document.createElement('div');
          box.className = 'tag-group';
          const title = document.createElement('strong'); title.textContent = g.tag.name; box.appendChild(title);
          for(const v of g.values){
            const lab = document.createElement('label');
            const input = document.createElement('input'); input.type='checkbox'; input.value=String(v.id); input.checked = selectedIds.has(v.id);
            lab.appendChild(input); lab.appendChild(document.createTextNode(' '+v.value));
            box.appendChild(lab);
            box.appendChild(document.createElement('br'));
          }
          container.appendChild(box);
        }
      }

      function openEventModal(mode, data){
        const wrap = document.getElementById('eventModalWrap');
        const titleEl = document.getElementById('evTitle');
        const startEl = document.getElementById('evStart');
        const endEl = document.getElementById('evEnd');
        const groupsEl = document.getElementById('evTagGroups');
        const copySelect = document.getElementById('evCopySelect');
        const canceledChk = document.getElementById('evCanceled');
        const contactEl = document.getElementById('evContact');
        const delBtn = document.getElementById('evDeleteBtn');
        const saveBtn = document.getElementById('evSaveBtn');
        const cancelBtn = document.getElementById('evCancelBtn');
        const modalTitle = document.getElementById('eventModalTitle');

        const selectedIds = new Set(data.tagValueIds || []);
        renderTagCheckboxes(groupsEl, selectedIds);

        titleEl.value = data.title || '';
        startEl.value = isoToLocalInputValue(data.startIso);
        endEl.value = isoToLocalInputValue(data.endIso);
        modalTitle.textContent = mode === 'create' ? 'Создание события' : 'Редактирование события';
        delBtn.style.display = mode === 'edit' ? 'inline-block' : 'none';
        canceledChk.checked = !!data.isCanceled;
        contactEl.value = data.contact || '';

        // Показ/скрытие элементов, актуальных только для редактирования
        const cancelWrap = canceledChk?.parentElement; // label с чекбоксом Отмена
        if (cancelWrap) cancelWrap.style.display = (mode === 'edit') ? 'inline-block' : 'none';
        const copyWrap = copySelect?.parentElement; // строка с селектом "Скопировать..."
        if (copyWrap) copyWrap.style.visibility = (mode === 'edit') ? 'visible' : 'hidden';

        const collectSelected = ()=> Array.from(groupsEl.querySelectorAll('input[type="checkbox"]:checked')).map(i=>Number(i.value));

        const onSave = async ()=>{
          const payload = {
            title: titleEl.value.trim(),
            dateFrom: localInputToIso(startEl.value),
            dateTo: localInputToIso(endEl.value),
            tagValueIds: collectSelected(),
            isCanceled: !!canceledChk.checked,
            contact: contactEl.value.trim() || null
          };
          if(!payload.title){ alert('Введите название'); return; }
          try{
            if(mode==='create'){
              await fetchJSON(`${API}/schedules`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
              window.calendar.refetchEvents();
            } else {
              await fetchJSON(`${API}/schedules/${data.id}`, { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
              window.calendar.refetchEvents();
            }
            closeEventModal();
          } catch (e) {
            // Сервер возвращает detail с текстом ошибки; попытаемся извлечь его
            let msg = 'Не удалось сохранить событие';
            try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
          }
        };

        const onDelete = async ()=>{
          if(confirm('Удалить событие?')){
            await fetch(`${API}/schedules/${data.id}`, { method:'DELETE' });
            const calEv = window.calendar.getEventById(String(data.id));
            if(calEv) calEv.remove();
            closeEventModal();
          }
        };

        const onCancel = ()=> closeEventModal();

        saveBtn.onclick = onSave;
        delBtn.onclick = onDelete;
        cancelBtn.onclick = onCancel;

        const onCopyChange = async ()=>{
          const val = copySelect.value;
          if(!val) return;
          // Множество смещений по дням: 1 -> [1], 7 -> [7], 14 -> [7,14], 21 -> [7,14,21], 28 -> [7,14,21,28]
          const preset = {
            '1d': [1],
            '7d': [7],
            '14d': [7, 14],
            '21d': [7, 14, 21],
            '28d': [7, 14, 21, 28],
          };
          const offsets = preset[val] || [];
          const srcStartIso = localInputToIso(startEl.value);
          const srcEndIso = localInputToIso(endEl.value);
          const srcStart = new Date(srcStartIso);
          const srcEnd = new Date(srcEndIso);
          const selectedIdsArr = collectSelected();

          // Предпроверка занятости всех дат для уникальных ресурсов
          const uniqueGroups = TAG_GROUPS.filter(g => !!g.tag.unique_resource);
          const uniqueGroupToSelectedValueIds = uniqueGroups.map(g => {
            const ids = new Set(selectedIdsArr);
            const groupIds = g.values.map(v => v.id).filter(id => ids.has(id));
            return { tagId: g.tag.id, valueIds: groupIds };
          }).filter(x => x.valueIds.length > 0);

          try {
            // Проверяем все смещения: если для любого смещения найдены конфликты — отменяем операцию
            for (const d of offsets) {
              const dstStart = new Date(srcStart.getTime()); dstStart.setDate(dstStart.getDate() + d);
              const dstEnd = new Date(srcEnd.getTime()); dstEnd.setDate(dstEnd.getDate() + d);
              const from = dstStart.toISOString();
              const to = dstEnd.toISOString();
              for (const grp of uniqueGroupToSelectedValueIds) {
                const params = new URLSearchParams();
                params.set('from', from);
                params.set('to', to);
                params.set('tag_value_ids', grp.valueIds.join(','));
                const found = await fetchJSON(`${API}/schedules?${params}`);
                if (Array.isArray(found) && found.length > 0) {
                  throw new Error(`Найдены пересечения для даты ${formatLocalNoSeconds(from)} — ${formatLocalNoSeconds(to)}`);
                }
              }
            }

            // Если все свободно — создаём все события
            const titleOut = (titleEl.value || '').trim() || (data.title || '');
            if(!titleOut){ alert('Введите название'); return; }
            for (const d of offsets) {
              const dstStart = new Date(srcStart.getTime()); dstStart.setDate(dstStart.getDate() + d);
              const dstEnd = new Date(srcEnd.getTime()); dstEnd.setDate(dstEnd.getDate() + d);
              const payload = {
                title: titleOut,
                dateFrom: dstStart.toISOString(),
                dateTo: dstEnd.toISOString(),
                tagValueIds: selectedIdsArr,
              };
              await fetchJSON(`${API}/schedules`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
            }
            window.calendar.refetchEvents();
            closeEventModal();
          } catch (e) {
            let msg = 'Не удалось скопировать событие. Найдены пересечения!';
            try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
          } finally {
            copySelect.value = '';
          }
        };
        copySelect.onchange = onCopyChange;

        wrap.classList.remove('hidden');
      }

      function closeEventModal(){
        document.getElementById('eventModalWrap').classList.add('hidden');
      }

      async function main() {
        const filtersEl = document.getElementById('filters');
        const filtersDrawerEl = document.getElementById('filtersDrawerContent');
        const printLegendEl = document.getElementById('printLegend');
        const printFiltersEl = document.getElementById('printFiltersSelected');
        SELECTED = new Set();
        await loadTagsWithValues();
        if (!window.highlightTagId && TAG_GROUPS.length) {
          window.highlightTagId = TAG_GROUPS[0].tag.id;
        }
        // Синхронный ререндер для обеих панелей фильтров
        window.syncFiltersUI = ()=>{
          renderFilters(filtersEl, TAG_GROUPS, SELECTED);
          if(filtersDrawerEl) renderFilters(filtersDrawerEl, TAG_GROUPS, SELECTED);
        };
        window.syncFiltersUI();

        // Синхронизация печатной легенды и списка выбранных фильтров
        window.syncPrintLegend = ()=>{
          if(printLegendEl){
            const hlId = window.highlightTagId;
            const grp = TAG_GROUPS.find(g => g.tag.id === hlId) || TAG_GROUPS[0] || null;
            renderPrintLegend(printLegendEl, grp);
          }
          if(printFiltersEl){
            renderPrintFiltersSelected(printFiltersEl, TAG_GROUPS, SELECTED);
          }
        };
        window.syncPrintLegend();

        const calendarEl = document.getElementById('calendar');
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const calendar = new FullCalendar.Calendar(calendarEl, {
          initialView: isMobile ? 'timeGridDay' : 'timeGridWeek',
          headerToolbar: { left: 'prev,next today', center: 'title', right: (isMobile ? 'dayGridMonth,timeGridDay' : 'dayGridMonth,timeGridWeek,timeGridDay') },
          locale: 'ru',
          firstDay: 1,
          slotMinTime: '07:00:00',
          scrollTime: '08:00:00',
          allDaySlot: false,
          height: '100%',
          selectable: true,
          editable: true,
          eventSources: [{
            events: async (info, success, failure) => {
              try {
                const params = new URLSearchParams();
                params.set('from', info.startStr);
                params.set('to', info.endStr);
                if (SELECTED.size) params.set('tag_value_ids', Array.from(SELECTED).join(','));
                const data = await fetchJSON(`${API}/schedules?${params}`);
                let events = data.map(e => ({ id: String(e.id), title: e.title, start: e.dateFrom, end: e.dateTo, extendedProps: { tagValueIds: e.tagValueIds, isCanceled: !!e.isCanceled, contact: e.contact || null } }));
                if(!SHOW_CANCELED){ events = events.filter(ev => !ev.extendedProps.isCanceled); }
                // Раскраска по выбранному тегу: цвет берём у значения; иначе серый
                const hlTagId = window.highlightTagId || null;
                if(hlTagId){
                  const tvColorMap = new Map();
                  for(const g of TAG_GROUPS){
                    if(g.tag.id === hlTagId){
                      for(const v of g.values){ tvColorMap.set(v.id, v.color || '#9ca3af'); }
                    }
                  }
                  for(const ev of events){
                    if(ev.extendedProps.isCanceled){
                      ev.backgroundColor = '#9ca3af'; ev.borderColor = '#9ca3af'; ev.textColor = '#000';
                      continue;
                    }
                    const tvIds = ev.extendedProps.tagValueIds || [];
                    let chosenColor = null;
                    for(const id of tvIds){ if(tvColorMap.has(id)){ chosenColor = tvColorMap.get(id); break; } }
                    const color = chosenColor || '#9ca3af';
                    ev.backgroundColor = color; ev.borderColor = color; ev.textColor = '#000';
                  }
                }
                success(events);
              } catch (err) { failure(err); }
            }
          }],
          select: async (arg) => {
            openEventModal('create', { startIso: arg.startStr, endIso: arg.endStr, tagValueIds: Array.from(SELECTED) });
          },
          eventDrop: async (info) => {
            const ev = info.event;
            try {
              await fetchJSON(`${API}/schedules/${ev.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dateFrom: ev.start.toISOString(), dateTo: ev.end?.toISOString() || ev.start.toISOString() }) });
            } catch (e) {
              let msg = 'Не удалось перенести событие';
              try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
              info.revert();
            }
          },
          eventResize: async (info) => {
            const ev = info.event;
            try {
              await fetchJSON(`${API}/schedules/${ev.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dateFrom: ev.start.toISOString(), dateTo: ev.end?.toISOString() || ev.start.toISOString() }) });
            } catch (e) {
              let msg = 'Не удалось изменить длительность события';
              try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
              info.revert();
            }
          },
          eventClick: async (info) => {
            const ev = info.event;
            openEventModal('edit', { id: Number(ev.id), title: ev.title, startIso: ev.start.toISOString(), endIso: (ev.end?.toISOString() || ev.start.toISOString()), tagValueIds: ev.extendedProps?.tagValueIds || [], isCanceled: !!ev.extendedProps?.isCanceled, contact: ev.extendedProps?.contact || '' });
          }
        });
        calendar.render();
        window.calendar = calendar;

        // Адаптировать высоту календаря под печать
        window.addEventListener('beforeprint', () => {
          try {
            window._prevCalHeight = window.calendar?.getOption('height');
            window.calendar?.setOption('height', 'auto');
            setTimeout(() => window.calendar?.updateSize(), 0);
          } catch(_) {}
        });
        window.addEventListener('afterprint', () => {
          try {
            const prev = window._prevCalHeight ?? '100%';
            window.calendar?.setOption('height', prev);
            setTimeout(() => window.calendar?.updateSize(), 0);
          } catch(_) {}
        });

        // Обновление заголовка (диапазона дат) для мобильной панели
        const mbTitle = document.getElementById('mbTitle');
        const refreshMbTitle = ()=>{ mbTitle.textContent = calendar.view.title; };
        calendar.on('datesSet', refreshMbTitle);
        refreshMbTitle();

        const openCreate = async ()=>{
          const now = new Date();
          const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 10, 0, 0).toISOString();
          const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 11, 0, 0).toISOString();
          openEventModal('create', { startIso: start, endIso: end, tagValueIds: Array.from(SELECTED) });
        };
        document.getElementById('createBtn').addEventListener('click', openCreate);
        document.getElementById('createBtnMobile').addEventListener('click', openCreate);
        document.getElementById('createBtnDrawer').addEventListener('click', openCreate);

        // Управление drawer (мобильные фильтры)
        const drawer = document.getElementById('filtersDrawer');
        const openFiltersBtn = document.getElementById('openFiltersBtn');
        const drawerClose = document.getElementById('drawerClose');
        openFiltersBtn.addEventListener('click', ()=> drawer.classList.add('open'));
        drawerClose.addEventListener('click', ()=> drawer.classList.remove('open'));
        drawer.addEventListener('click', (e)=>{ if(e.target === drawer) drawer.classList.remove('open'); });
        // При начале работы синхронизируем фильтры в drawer
        if(window.syncFiltersUI) window.syncFiltersUI();

        // Навигация и переключатели представлений на мобильной панели
        document.getElementById('mbPrev').addEventListener('click', ()=> calendar.prev());
        document.getElementById('mbNext').addEventListener('click', ()=> calendar.next());
        document.getElementById('mbToday').addEventListener('click', ()=> calendar.today());
        const mbMonth = document.getElementById('mbMonth');
        const mbDay = document.getElementById('mbDay');
        const setActive = (btn)=>{
          [mbMonth, mbDay].forEach(b=> b.classList.toggle('active', b === btn));
        };
        mbMonth.addEventListener('click', ()=>{ calendar.changeView('dayGridMonth'); setActive(mbMonth); });
        mbDay.addEventListener('click', ()=>{ calendar.changeView('timeGridDay'); setActive(mbDay); });
      }

      main().catch(err => console.error(err));
    </script>
  </body>
  </html>


