<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Scheduler</title>
    <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.css" rel="stylesheet" />
    <style>
      html, body { height: 100%; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; overflow: hidden; }
      #app { display: grid; grid-template-columns: 300px 1fr; height: 100vh; }
      aside { border-right: 1px solid #e5e7eb; padding: 12px; overflow: auto; }
      main { padding: 12px; display: flex; flex-direction: column; overflow: hidden; }
      .tag-values { display: flex; flex-direction: column; gap: 6px; max-height: 40vh; overflow: auto; }
      .tag-line { display:flex; align-items:center; gap:6px; }
      .color-dot { display:inline-block; width: 10px; height: 10px; border-radius: 50%; border:1px solid #d1d5db; }
      .filters { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; }
      .section { margin-top: 16px; }
      .row { display: flex; align-items: center; gap: 6px; }
      .muted { color: #6b7280; font-size: 12px; }
      button { cursor: pointer; }
      input[type="text"], input[type="datetime-local"] { padding: 6px; }
      /* Modal */
      .hidden { display: none; }
      .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); display: flex; align-items: center; justify-content: center; z-index: 50; }
      .modal-backdrop.hidden { display: none !important; }
      .modal { background: #fff; border-radius: 8px; padding: 16px; width: 520px; max-width: calc(100% - 24px); box-shadow: 0 10px 30px rgba(0,0,0,.2); }
      .modal h3 { margin: 0 0 12px 0; }
      .modal .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .modal .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
      .tag-groups { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; max-height: 220px; overflow: auto; border: 1px solid #e5e7eb; padding: 8px; border-radius: 6px; }
      .tag-group { border: 1px dashed #e5e7eb; padding: 6px; border-radius: 6px; }
      .tag-group strong { font-size: 12px; color: #374151; }
      .tag-list, .value-list { display: flex; flex-direction: column; gap: 4px; margin: 6px 0; }
      .tag-header { display: flex; align-items: center; justify-content: space-between; gap: 6px; }
      /* Календарь занимает всю доступную высоту, скролл только внутри него */
      #calendar { flex: 1; min-height: 0; }
      /* Подсветка выходных (суббота и воскресенье) */
      .fc .fc-col-header-cell.fc-day-sat,
      .fc .fc-col-header-cell.fc-day-sun { background: #f8fafc; }
      .fc .fc-daygrid-day.fc-day-sat,
      .fc .fc-daygrid-day.fc-day-sun { background: #f8fafc; }
      .fc .fc-timegrid-col.fc-day-sat,
      .fc .fc-timegrid-col.fc-day-sun { background: #f8fafc; }
      /* Мобильная панель и drawer */
      .mobile-bar { display: none; }
      .drawer { position: fixed; inset: 0; background: rgba(0,0,0,.35); display: none; z-index: 60; }
      .drawer.open { display: block; }
      .drawer-panel { width: 86vw; max-width: 360px; height: 100%; background: #fff; padding: 12px; overflow: auto; border-right: 1px solid #e5e7eb; }
      .drawer-header { display:flex; align-items:center; justify-content: space-between; margin-bottom: 8px; }
      .drawer-close { background: transparent; border: none; font-size: 18px; cursor: pointer; }
      @media (max-width: 768px){
        #app { grid-template-columns: 1fr; }
        aside { display: none; }
        .mobile-bar { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <aside>
        <div class="row" style="justify-content: space-between; align-items: baseline;">
          <h3 style="margin:0;">Фильтры</h3>
          <a href="/tags.html" class="muted">редактировать</a>
        </div>
        <div id="filters"></div>
        <button id="createBtn">+ Событие</button>
      </aside>
      <main>
        <div class="mobile-bar">
          <button id="openFiltersBtn">Фильтры</button>
          <button id="createBtnMobile">+ Событие</button>
        </div>
        <div id="calendar"></div>
      </main>
    </div>

    <!-- Мобильный drawer с фильтрами -->
    <div id="filtersDrawer" class="drawer">
      <div class="drawer-panel">
        <div class="drawer-header">
          <strong>Фильтры</strong>
          <button id="drawerClose" class="drawer-close" aria-label="Закрыть">×</button>
        </div>
        <div id="filtersDrawerContent"></div>
        <button id="createBtnDrawer">+ Событие</button>
      </div>
    </div>

    <!-- Модальное окно события -->
    <div id="eventModalWrap" class="modal-backdrop hidden">
      <div class="modal">
        <h3 id="eventModalTitle">Событие</h3>
        <div class="grid">
          <div class="row"><input id="evTitle" type="text" placeholder="Название" style="width:100%"/></div>
          <div></div>
          <div>
            <label class="muted">Начало</label>
            <input id="evStart" type="datetime-local" style="width:100%"/>
          </div>
          <div>
            <label class="muted">Окончание</label>
            <input id="evEnd" type="datetime-local" style="width:100%"/>
          </div>
          <div style="grid-column: 1 / -1;">
            <label class="muted">Значения тегов</label>
            <div id="evTagGroups" class="tag-groups"></div>
          </div>
        </div>
        <div class="actions">
          <button id="evDeleteBtn" style="margin-right:auto; color:#b91c1c;">Удалить</button>
          <button id="evCancelBtn">Отмена</button>
          <button id="evSaveBtn">Сохранить</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>
    <script>
      const API = '/api';

      async function fetchJSON(url, opts) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      // Утилита: форматировать ISO в локальное время без секунд: YYYY-MM-DD HH:MM
      function formatLocalNoSeconds(iso){
        const d = new Date(iso);
        const pad = (n)=> String(n).padStart(2,'0');
        const yyyy = d.getFullYear();
        const mm = pad(d.getMonth()+1);
        const dd = pad(d.getDate());
        const hh = pad(d.getHours());
        const mi = pad(d.getMinutes());
        return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
      }
      // Заменить все ISO-строки в сообщении об ошибке на локальный формат без секунд
      function beautifyErrorMessage(msg){
        const isoRe = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})/g;
        return String(msg).replace(isoRe, (m)=>{
          try { return formatLocalNoSeconds(m); } catch(_) { return m; }
        });
      }

      // Глобальные состояния
      let TAG_GROUPS = [];
      let SELECTED = new Set();

      async function loadTagsWithValues() {
        const tags = await fetchJSON(`${API}/tags`);
        const result = [];
        for (const t of tags) {
          const values = await fetchJSON(`${API}/tags/${t.id}/values`);
          result.push({ tag: t, values });
        }
        TAG_GROUPS = result;
        return result;
      }

      function renderFilters(cont, groups, state) {
        cont.innerHTML = '';
        // Выпадающий список для выбора основного тега для подсветки
        const selectWrap = document.createElement('div'); selectWrap.className = 'tag-values';
        const selectTitle = document.createElement('div'); selectTitle.className='muted'; selectTitle.textContent = 'Основной тег для подсветки:';
        selectWrap.appendChild(selectTitle);
        const select = document.createElement('select');
        for (const g of groups) {
          const opt = document.createElement('option');
          opt.value = String(g.tag.id);
          opt.textContent = g.tag.name;
          select.appendChild(opt);
        }
        if (!window.highlightTagId && groups.length) {
          window.highlightTagId = groups[0].tag.id;
        }
        if (window.highlightTagId) {
          select.value = String(window.highlightTagId);
        }
        select.addEventListener('change', () => {
          window.highlightTagId = Number(select.value);
          if (window.calendar) window.calendar.refetchEvents();
        });
        selectWrap.appendChild(select);
        cont.appendChild(selectWrap);
        // Чекбоксы для фильтрации по значениям
        for (const g of groups) {
          const h = document.createElement('div');
          h.innerHTML = `<strong>${g.tag.name}</strong>`;
          cont.appendChild(h);
          const box = document.createElement('div');
          box.className = 'tag-values';
          for (const v of g.values) {
            const id = `tv-${v.id}`;
            const checked = state.has(v.id) ? 'checked' : '';
            const item = document.createElement('label');
            item.innerHTML = `<input type="checkbox" id="${id}" ${checked}/> <span class="color-dot" style="background:${v.color || '#9ca3af'}"></span> ${v.value}`;
            item.querySelector('input').addEventListener('change', (e)=>{
              if (e.target.checked) state.add(v.id); else state.delete(v.id);
              window.calendar.refetchEvents();
              if(window.syncFiltersUI) window.syncFiltersUI();
            });
            box.appendChild(item);
          }
          cont.appendChild(box);
        }
      }

      // Управление тегами вынесено на /tags.html. На главной оставлены только фильтры.

      // МОДАЛ СОБЫТИЯ
      function isoToLocalInputValue(iso){
        const d = new Date(iso);
        const pad = (n)=> String(n).padStart(2,'0');
        const yyyy = d.getFullYear();
        const mm = pad(d.getMonth()+1);
        const dd = pad(d.getDate());
        const hh = pad(d.getHours());
        const mi = pad(d.getMinutes());
        return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
      }
      function localInputToIso(val){
        const d = new Date(val);
        return d.toISOString();
      }

      function renderTagCheckboxes(container, selectedIds){
        container.innerHTML = '';
        for(const g of TAG_GROUPS){
          const box = document.createElement('div');
          box.className = 'tag-group';
          const title = document.createElement('strong'); title.textContent = g.tag.name; box.appendChild(title);
          for(const v of g.values){
            const lab = document.createElement('label');
            const input = document.createElement('input'); input.type='checkbox'; input.value=String(v.id); input.checked = selectedIds.has(v.id);
            lab.appendChild(input); lab.appendChild(document.createTextNode(' '+v.value));
            box.appendChild(lab);
            box.appendChild(document.createElement('br'));
          }
          container.appendChild(box);
        }
      }

      function openEventModal(mode, data){
        const wrap = document.getElementById('eventModalWrap');
        const titleEl = document.getElementById('evTitle');
        const startEl = document.getElementById('evStart');
        const endEl = document.getElementById('evEnd');
        const groupsEl = document.getElementById('evTagGroups');
        const delBtn = document.getElementById('evDeleteBtn');
        const saveBtn = document.getElementById('evSaveBtn');
        const cancelBtn = document.getElementById('evCancelBtn');
        const modalTitle = document.getElementById('eventModalTitle');

        const selectedIds = new Set(data.tagValueIds || []);
        renderTagCheckboxes(groupsEl, selectedIds);

        titleEl.value = data.title || '';
        startEl.value = isoToLocalInputValue(data.startIso);
        endEl.value = isoToLocalInputValue(data.endIso);
        modalTitle.textContent = mode === 'create' ? 'Создание события' : 'Редактирование события';
        delBtn.style.display = mode === 'edit' ? 'inline-block' : 'none';

        const collectSelected = ()=> Array.from(groupsEl.querySelectorAll('input[type="checkbox"]:checked')).map(i=>Number(i.value));

        const onSave = async ()=>{
          const payload = {
            title: titleEl.value.trim(),
            dateFrom: localInputToIso(startEl.value),
            dateTo: localInputToIso(endEl.value),
            tagValueIds: collectSelected()
          };
          if(!payload.title){ alert('Введите название'); return; }
          try{
            if(mode==='create'){
              await fetchJSON(`${API}/schedules`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
              window.calendar.refetchEvents();
            } else {
              await fetchJSON(`${API}/schedules/${data.id}`, { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
              window.calendar.refetchEvents();
            }
            closeEventModal();
          } catch (e) {
            // Сервер возвращает detail с текстом ошибки; попытаемся извлечь его
            let msg = 'Не удалось сохранить событие';
            try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
          }
        };

        const onDelete = async ()=>{
          if(confirm('Удалить событие?')){
            await fetch(`${API}/schedules/${data.id}`, { method:'DELETE' });
            const calEv = window.calendar.getEventById(String(data.id));
            if(calEv) calEv.remove();
            closeEventModal();
          }
        };

        const onCancel = ()=> closeEventModal();

        saveBtn.onclick = onSave;
        delBtn.onclick = onDelete;
        cancelBtn.onclick = onCancel;

        wrap.classList.remove('hidden');
      }

      function closeEventModal(){
        document.getElementById('eventModalWrap').classList.add('hidden');
      }

      async function main() {
        const filtersEl = document.getElementById('filters');
        const filtersDrawerEl = document.getElementById('filtersDrawerContent');
        SELECTED = new Set();
        await loadTagsWithValues();
        if (!window.highlightTagId && TAG_GROUPS.length) {
          window.highlightTagId = TAG_GROUPS[0].tag.id;
        }
        // Синхронный ререндер для обеих панелей фильтров
        window.syncFiltersUI = ()=>{
          renderFilters(filtersEl, TAG_GROUPS, SELECTED);
          if(filtersDrawerEl) renderFilters(filtersDrawerEl, TAG_GROUPS, SELECTED);
        };
        window.syncFiltersUI();

        const calendarEl = document.getElementById('calendar');
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const calendar = new FullCalendar.Calendar(calendarEl, {
          initialView: isMobile ? 'timeGridDay' : 'timeGridWeek',
          headerToolbar: { left: 'prev,next today', center: 'title', right: (isMobile ? 'dayGridMonth,timeGridDay' : 'dayGridMonth,timeGridWeek,timeGridDay') },
          locale: 'ru',
          firstDay: 1,
          slotMinTime: '07:00:00',
          scrollTime: '08:00:00',
          allDaySlot: false,
          height: '100%',
          selectable: true,
          editable: true,
          eventSources: [{
            events: async (info, success, failure) => {
              try {
                const params = new URLSearchParams();
                params.set('from', info.startStr);
                params.set('to', info.endStr);
                if (SELECTED.size) params.set('tag_value_ids', Array.from(SELECTED).join(','));
                const data = await fetchJSON(`${API}/schedules?${params}`);
                const events = data.map(e => ({ id: String(e.id), title: e.title, start: e.dateFrom, end: e.dateTo, extendedProps: { tagValueIds: e.tagValueIds } }));
                // Раскраска по выбранному тегу: цвет берём у значения; иначе серый
                const hlTagId = window.highlightTagId || null;
                if(hlTagId){
                  const tvColorMap = new Map();
                  for(const g of TAG_GROUPS){
                    if(g.tag.id === hlTagId){
                      for(const v of g.values){ tvColorMap.set(v.id, v.color || '#9ca3af'); }
                    }
                  }
                  for(const ev of events){
                    const tvIds = ev.extendedProps.tagValueIds || [];
                    let chosenColor = null;
                    for(const id of tvIds){ if(tvColorMap.has(id)){ chosenColor = tvColorMap.get(id); break; } }
                    const color = chosenColor || '#9ca3af';
                    ev.backgroundColor = color; ev.borderColor = color; ev.textColor = '#fff';
                  }
                }
                success(events);
              } catch (err) { failure(err); }
            }
          }],
          select: async (arg) => {
            openEventModal('create', { startIso: arg.startStr, endIso: arg.endStr, tagValueIds: Array.from(SELECTED) });
          },
          eventDrop: async (info) => {
            const ev = info.event;
            try {
              await fetchJSON(`${API}/schedules/${ev.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dateFrom: ev.start.toISOString(), dateTo: ev.end?.toISOString() || ev.start.toISOString() }) });
            } catch (e) {
              let msg = 'Не удалось перенести событие';
              try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
              info.revert();
            }
          },
          eventResize: async (info) => {
            const ev = info.event;
            try {
              await fetchJSON(`${API}/schedules/${ev.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dateFrom: ev.start.toISOString(), dateTo: ev.end?.toISOString() || ev.start.toISOString() }) });
            } catch (e) {
              let msg = 'Не удалось изменить длительность события';
              try { const j = JSON.parse(String(e.message || '')); if(j?.detail) msg = j.detail; } catch(_) {}
            alert(beautifyErrorMessage(msg));
              info.revert();
            }
          },
          eventClick: async (info) => {
            const ev = info.event;
            openEventModal('edit', { id: Number(ev.id), title: ev.title, startIso: ev.start.toISOString(), endIso: (ev.end?.toISOString() || ev.start.toISOString()), tagValueIds: ev.extendedProps?.tagValueIds || [] });
          }
        });
        calendar.render();
        window.calendar = calendar;

        const openCreate = async ()=>{
          const now = new Date();
          const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 10, 0, 0).toISOString();
          const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 11, 0, 0).toISOString();
          openEventModal('create', { startIso: start, endIso: end, tagValueIds: Array.from(SELECTED) });
        };
        document.getElementById('createBtn').addEventListener('click', openCreate);
        document.getElementById('createBtnMobile').addEventListener('click', openCreate);
        document.getElementById('createBtnDrawer').addEventListener('click', openCreate);

        // Управление drawer (мобильные фильтры)
        const drawer = document.getElementById('filtersDrawer');
        const openFiltersBtn = document.getElementById('openFiltersBtn');
        const drawerClose = document.getElementById('drawerClose');
        openFiltersBtn.addEventListener('click', ()=> drawer.classList.add('open'));
        drawerClose.addEventListener('click', ()=> drawer.classList.remove('open'));
        drawer.addEventListener('click', (e)=>{ if(e.target === drawer) drawer.classList.remove('open'); });
        // При начале работы синхронизируем фильтры в drawer
        if(window.syncFiltersUI) window.syncFiltersUI();
      }

      main().catch(err => console.error(err));
    </script>
  </body>
  </html>


